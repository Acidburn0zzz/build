URL: http://buildbot.net/trac
Version: 0.8.4p1
License: GNU General Public License (GPL) Version 2

This is a forked copy of buildbot v0.8.4p1.


Add extra parameters to HttpStatusPush as a very basic authentication mechanism.

diff --git a/third_party/buildbot_8_4p1/buildbot/status/status_push.py b/third_party/buildbot_8_4p1/buildbot/status/status_push.py
index b7b3b0a..ca83fdb 100644
--- a/third_party/buildbot_8_4p1/buildbot/status/status_push.py
+++ b/third_party/buildbot_8_4p1/buildbot/status/status_push.py
@@ -328,7 +328,7 @@ class HttpStatusPush(StatusPush):

     def __init__(self, serverUrl, debug=None, maxMemoryItems=None,
                  maxDiskItems=None, chunkSize=200, maxHttpRequestSize=2**20,
-                 **kwargs):
+                 extra_post_params=None, **kwargs):
         """
         @serverUrl: Base URL to be used to push events notifications.
         @maxMemoryItems: Maximum number of items to keep queued in memory.
@@ -341,6 +341,7 @@ class HttpStatusPush(StatusPush):
         """
         # Parameters.
         self.serverUrl = serverUrl
+        self.extra_post_params = extra_post_params or {}
         self.debug = debug
         self.chunkSize = chunkSize
         self.lastPushWasSuccessful = True
@@ -378,7 +379,9 @@ class HttpStatusPush(StatusPush):
                 packets = json.dumps(items, indent=2, sort_keys=True)
             else:
                 packets = json.dumps(items, separators=(',',':'))
-            data = urllib.urlencode({'packets': packets})
+            params = {'packets': packets}
+            params.update(self.extra_post_params)
+            data = urllib.urlencode(params)
             if (not self.maxHttpRequestSize or
                 len(data) < self.maxHttpRequestSize):
                 return (data, items)
@@ -395,6 +398,8 @@ class HttpStatusPush(StatusPush):

     def pushHttp(self):
         """Do the HTTP POST to the server."""
+        if not self.serverUrl:
+            return
         (encoded_packets, items) = self.popChunk()

         def Success(result):




Increase console customization build range.

diff --git a/third_party/buildbot_8_4p1/buildbot/status/web/console.py b/third_party/buildbot_8_4p1/buildbot/status/web/console.py
index b00b871..e513ec0 100644
--- a/third_party/buildbot_8_4p1/buildbot/status/web/console.py
+++ b/third_party/buildbot_8_4p1/buildbot/status/web/console.py
@@ -727,10 +727,10 @@ class ConsoleStatusResource(HtmlResource):
         # Keep only the revisions we care about.
         # By default we process the last 40 revisions.
         # If a dev name is passed, we look for the changes by this person in the
-        # last 80 revisions.
+        # last 160 revisions.
         numRevs = int(request.args.get("revs", [40])[0])
         if devName:
-            numRevs *= 2
+            numRevs *= 4
         numBuilds = numRevs

         # Get all changes we can find.  This is a DB operation, so it must use



Port console caching from 0.8.3p1 to 0.8.4p1.
    
diff --git a/third_party/buildbot_8_4p1/buildbot/status/web/console.py b/third_party/buildbot_8_4p1/buildbot/status/web/console.py
index 59cbc0e..c95ac7f 100644
--- a/third_party/buildbot_8_4p1/buildbot/status/web/console.py
+++ b/third_party/buildbot_8_4p1/buildbot/status/web/console.py
@@ -53,12 +53,74 @@ def getResultsClass(results, prevResults, inProgress):
         else:
             # The previous build also failed.
             return "warnings"
-  
+
     # Any other results? Like EXCEPTION?
     return "exception"
 
 class ANYBRANCH: pass # a flag value, used below
 
+class CachedStatusBox(object):
+    """Basic data class to remember the information for a box on the console."""
+    def __init__(self, color, pageTitle, details, url, tag):
+        self.color = color
+        self.pageTitle = pageTitle
+        self.details = details
+        self.url = url
+        self.tag = tag
+
+
+class CacheStatus(object):
+    """Basic cache of CachedStatusBox based on builder names and revisions.
+
+    Current limitation: If the revisions are not numerically increasing, the
+                        "trim" feature will not work and the cache will grow
+                        indefinitely.
+    """
+    def __init__(self):
+      self.allBoxes = dict()
+
+    def display(self):
+        """Display the available data in the cache. Used for debugging only."""
+        data = ""
+        for builder in self.allBoxes:
+            for revision in self.allBoxes[builder]:
+               data += "%s %s %s\n" % (builder, str(revision),
+                                       self.allBoxes[builder][revision].color)
+        return data
+
+    def insert(self, builderName, revision, color, pageTitle, details, url, tag):
+        """Insert a new build into the cache."""
+        box = CachedStatusBox(color, pageTitle, details, url, tag)
+        if not self.allBoxes.get(builderName):
+            self.allBoxes[builderName] = {}
+
+        self.allBoxes[builderName][revision] = box
+
+    def get(self, builderName, revision):
+        """Retrieve a build from the cache."""
+        if not self.allBoxes.get(builderName):
+          return None
+        if not self.allBoxes[builderName].get(revision):
+          return None
+        return self.allBoxes[builderName][revision]
+
+    def trim(self):
+        """Remove old revisions from the cache. (For integer revisions only)"""
+        try:
+            for builder in self.allBoxes:
+                allRevs = []
+                for revision in self.allBoxes[builder]:
+                  allRevs.append(revision)
+
+                if len(allRevs) > 250:
+                   allRevs.sort(cmp=lambda x,y: cmp(int(x), int(y)))
+                   deleteCount = len(allRevs) - 250
+                   for i in range(0, deleteCount):
+                     del self.allBoxes[builder][allRevs[i]]
+        except:
+            pass
+
+
 class DevRevision:
     """Helper class that contains all the information we need for a revision."""
 
@@ -97,6 +159,7 @@ class ConsoleStatusResource(HtmlResource):
         HtmlResource.__init__(self)
 
         self.status = None
+        self.cache = CacheStatus()
 
         if orderByTime:
             self.comparator = TimeRevisionComparator()
@@ -133,22 +196,22 @@ class ConsoleStatusResource(HtmlResource):
     def fetchChangesFromHistory(self, status, max_depth, max_builds, debugInfo):
         """Look at the history of the builders and try to fetch as many changes
         as possible. We need this when the main source does not contain enough
-        sourcestamps. 
+        sourcestamps.
 
         max_depth defines how many builds we will parse for a given builder.
         max_builds defines how many builds total we want to parse. This is to
             limit the amount of time we spend in this function.
-        
+
         This function is sub-optimal, but the information returned by this
         function is cached, so this function won't be called more than once.
         """
-        
+
         allChanges = list()
         build_count = 0
         for builderName in status.getBuilderNames()[:]:
             if build_count > max_builds:
                 break
-            
+
             builder = status.getBuilder(builderName)
             build = self.getHeadBuild(builder)
             depth = 0
@@ -160,7 +223,7 @@ class ConsoleStatusResource(HtmlResource):
                 build = build.getPreviousBuild()
 
         debugInfo["source_fetch_len"] = len(allChanges)
-        return allChanges                
+        return allChanges
 
     @defer.deferredGenerator
     def getAllChanges(self, request, status, debugInfo):
@@ -191,6 +254,7 @@ class ConsoleStatusResource(HtmlResource):
             prevChange = change
         allChanges = newChanges
 
+        debugInfo["source_len"] = len(allChanges)
         yield allChanges
 
     def getBuildDetails(self, request, builderName, build):
@@ -232,7 +296,7 @@ class ConsoleStatusResource(HtmlResource):
         build, and we go down until we find a build that was built prior to the
         last change we are interested in."""
 
-        revision = lastRevision 
+        revision = lastRevision
 
         builds = []
         build = self.getHeadBuild(builder)
@@ -299,7 +363,7 @@ class ConsoleStatusResource(HtmlResource):
         display the console page. The key is the builder name, and the value is
         an array of build we care about. We also returns a dictionary of
         builders we care about. The key is it's category.
- 
+
         lastRevision is the last revision we want to display in the page.
         categories is a list of categories to display. It is coming from the
             HTTP GET parameters.
@@ -364,7 +428,7 @@ class ConsoleStatusResource(HtmlResource):
         
         cs = []
         
-        for category in categories:            
+        for category in categories:
             c = {}
 
             c["name"] = category
@@ -372,9 +436,9 @@ class ConsoleStatusResource(HtmlResource):
             # To be able to align the table correctly, we need to know
             # what percentage of space this category will be taking. This is
             # (#Builders in Category) / (#Builders Total) * 100.
-            c["size"] = (len(builderList[category]) * 100) / count            
+            c["size"] = (len(builderList[category]) * 100) / count
             cs.append(c)
-            
+
         return cs
 
     def displaySlaveLine(self, status, builderList, debugInfo):
@@ -448,6 +512,23 @@ class ConsoleStatusResource(HtmlResource):
                 introducedIn = None
                 firstNotIn = None
 
+                cached_value = self.cache.get(builder, revision.revision)
+                if cached_value:
+                    debugInfo["from_cache"] += 1
+
+                    b = {}
+                    b["url"] = cached_value.url
+                    b["pageTitle"] = cached_value.pageTitle
+                    b["color"] = cached_value.color
+                    b["tag"] = cached_value.tag
+
+                    builds[category].append(b)
+
+                    if cached_value.details and cached_value.color == "failure":
+                         details.append(cached_value.details)
+
+                    continue
+
                 # Find the first build that does not include the revision.
                 for build in allBuilds[builder]:
                     if self.comparator.isRevisionEarlier(build, revision):
@@ -504,6 +585,13 @@ class ConsoleStatusResource(HtmlResource):
                 if current_details and resultsClass == "failure":
                     details.append(current_details)
 
+                # Add this box to the cache if it's completed so we don't have
+                # to compute it again.
+                if resultsClass not in ("running", "notstarted"):
+                  debugInfo["added_blocks"] += 1
+                  self.cache.insert(builder, revision.revision, resultsClass,
+                                    pageTitle, current_details, url, tag)
+
         return (builds, details)
 
     def filterRevisions(self, revisions, filter=None, max_revs=None):
@@ -553,7 +641,8 @@ class ConsoleStatusResource(HtmlResource):
 
         if builderList:
             subs["categories"] = self.displayCategories(builderList, debugInfo)
-            subs['slaves'] = self.displaySlaveLine(status, builderList, debugInfo)
+            subs['slaves'] = self.displaySlaveLine(status, builderList,
+                                                   debugInfo)
         else:
             subs["categories"] = []
 
@@ -574,14 +663,14 @@ class ConsoleStatusResource(HtmlResource):
 
             # Display the status for all builders.
             (builds, details) = self.displayStatusLine(builderList,
-                                            allBuilds,
-                                            revision,
-                                            debugInfo)
+                                                       allBuilds,
+                                                       revision,
+                                                       debugInfo)
             r['builds'] = builds
             r['details'] = details
 
             # Calculate the td span for the comment and the details.
-            r["span"] = len(builderList) + 2            
+            r["span"] = len(builderList) + 2
 
             subs['revisions'].append(r)
 
@@ -678,6 +767,13 @@ class ConsoleStatusResource(HtmlResource):
                                                     debugInfo)
 
             debugInfo["added_blocks"] = 0
+            debugInfo["from_cache"] = 0
+
+            if request.args.get("display_cache", None):
+                data = ""
+                data += "\nGlobal Cache\n"
+                data += self.cache.display()
+                return data
 
             cxt.update(self.displayPage(request, status, builderList,
                                         allBuilds, revisions, categories,
@@ -686,6 +782,11 @@ class ConsoleStatusResource(HtmlResource):
             templates = request.site.buildbot_service.templates
             template = templates.get_template("console.html")
             data = template.render(cxt)
+
+            # Clean up the cache.
+            if debugInfo["added_blocks"]:
+              self.cache.trim()
+
             return data
         d.addCallback(got_changes)
         return d


Add revision to changes in the waterfall.

diff --git a/third_party/buildbot_8_4p1/buildbot/status/web/changes.py b/third_party/buildbo
index 415e781..a15dff8 100644
--- a/third_party/buildbot_8_4p1/buildbot/status/web/changes.py
+++ b/third_party/buildbot_8_4p1/buildbot/status/web/changes.py
@@ -63,7 +63,8 @@ class ChangeBox(components.Adapter):
         template = req.site.buildbot_service.templates.get_template("change_macros.html")
         text = template.module.box_contents(url=url,
                                             who=self.original.getShortAuthor(),
-                                            pageTitle=self.original.comments)
+                                            pageTitle=self.original.comments,
+                                            revision=self.original.revision)
         return Box([text], class_="Change")
 components.registerAdapter(ChangeBox, Change, IBox)

diff --git a/third_party/buildbot_8_4p1/buildbot/status/web/templates/change_macros.html b/t
index b9b7780..9a37b47 100644
--- a/third_party/buildbot_8_4p1/buildbot/status/web/templates/change_macros.html
+++ b/third_party/buildbot_8_4p1/buildbot/status/web/templates/change_macros.html
@@ -67,6 +67,6 @@
 {% endif %}
 {%- endmacro %}

-{% macro box_contents(who, url, pageTitle) -%}
-<a href="{{ url }}" title="{{ pageTitle|e }}">{{ who|user }}</a>
+{% macro box_contents(who, url, pageTitle, revision) -%}
+<a href="{{ url }}" title="{{ pageTitle|e }}">{{ who|user }}</a><br>r{{ revision }}
 {%- endmacro %}




commit e6b9fad4373d6e55f7957ee8312d58cf0461d98c
Author: Chase Phillips <cmp@google.com>
Date:   Mon Jul 25 10:46:54 2011 -0700

    Import upstream fix: set journal mode.

    SQLite database fix from buildbot.net to increase
    concurrency.  This is 4050c5e7a:
    https://github.com/buildbot/buildbot/commit/4050c5e7a2641df56f792b06fc1aea6c16221e8f#diff-0

diff --git a/third_party/buildbot_8_4p1/buildbot/db/enginestrategy.py b/third_party/buildbot_8_4p1/buildbot/db/enginestrategy.py
index 7be9196..3d05cb6 100644
--- a/third_party/buildbot_8_4p1/buildbot/db/enginestrategy.py
+++ b/third_party/buildbot_8_4p1/buildbot/db/enginestrategy.py
@@ -25,6 +25,7 @@ special cases that Buildbot needs.  Those include:

 import os
 import sqlalchemy
+from twisted.python import log
 from sqlalchemy.engine import strategies, url
 from sqlalchemy.pool import NullPool

@@ -83,6 +84,16 @@ class BuildbotEngineStrategy(strategies.ThreadLocalEngineStrategy):

         return u, kwargs, max_conns

+    def set_up_sqlite_engine(self, u, engine):
+        """Special setup for sqlite engines"""
+        # try to enable WAL logging
+        if u.database:
+            log.msg("setting database journal mode to 'wal'")
+            try:
+                engine.execute("pragma journal_mode = wal")
+            except:
+                log.msg("failed to set journal mode - database may fail")
+
     def special_case_mysql(self, u, kwargs):
         """For mysql, take max_idle out of the query arguments, and
         use its value for pool_recycle.  Also, force use_unicode and
@@ -148,9 +159,12 @@ class BuildbotEngineStrategy(strategies.ThreadLocalEngineStrategy):
         # by DBConnector to configure the surrounding thread pool
         engine.optimal_thread_pool_size = max_conns

-        # and keep the basedir
+        # keep the basedir
         engine.buildbot_basedir = basedir

+        if u.drivername.startswith('sqlite'):
+            self.set_up_sqlite_engine(u, engine)
+
         return engine

 BuildbotEngineStrategy()



commit a2a0d76cbd2b016b628decf36ef8e298a9b1e4e8
Author: Chase Phillips <cmp@google.com>
Date:   Thu Jul 28 16:24:09 2011 -0700

    Backport postgres fix from Buildbot trunk.

    This fixes http://trac.buildbot.net/ticket/2010.

diff --git a/third_party/buildbot_8_4p1/buildbot/db/buildrequests.py b/third_party/buildbot_8_4p1/buildbot/db/buildrequests.py
index 650ac5d..b7d2b08 100644
--- a/third_party/buildbot_8_4p1/buildbot/db/buildrequests.py
+++ b/third_party/buildbot_8_4p1/buildbot/db/buildrequests.py
@@ -206,8 +206,6 @@ class BuildRequestsConnectorComponent(base.DBConnectorComponent):
             master_incarnation = self.db.master.master_incarnation
             tbl = self.db.model.buildrequests

-            transaction = conn.begin()
-
             # first, create a temporary table containing all of the ID's
             # we want to claim
             tmp_meta = sa.MetaData(bind=conn)
@@ -216,6 +214,8 @@ class BuildRequestsConnectorComponent(base.DBConnectorComponent):
                     prefixes=['TEMPORARY'])
             tmp.create()

+            transaction = conn.begin()
+
             try:
                 q = tmp.insert()
                 conn.execute(q, [ dict(brid=id) for id in brids ])
@@ -268,8 +268,10 @@ class BuildRequestsConnectorComponent(base.DBConnectorComponent):
                         raise AlreadyClaimedError
                 res.close()
             finally:
-                # clean up after ourselves, even though it's a temporary table
-                tmp.drop(checkfirst=True)
+                # clean up after ourselves, even though it's a temporary table;
+                # note that checkfirst=True does not work here for Postgres
+                # (#2010).
+                tmp.drop()

         return self.db.pool.do(thd)


Truncate commit comments to 1024 characters, which is the maximum size in the
db schema (see buildbot/db/model.py:181).

--- buildbot/db/changes.py	(revision 103214)
+++ buildbot/db/changes.py	(working copy)
@@ -53,7 +53,7 @@
       string)
     """
 
-    def addChange(self, author=None, files=None, comments=None, is_dir=0,
+    def addChange(self, author=None, files=None, comments='', is_dir=0,
             links=None, revision=None, when_timestamp=None, branch=None,
             category=None, revlink='', properties={}, repository='',
             project='', _reactor=reactor):
@@ -130,7 +130,7 @@
             ins = self.db.model.changes.insert()
             r = conn.execute(ins, dict(
                 author=author,
-                comments=comments,
+                comments=comments[:1024],
                 is_dir=is_dir,
                 branch=branch,
                 revision=revision,


Fix inheritance bug.

http://trac.buildbot.net/ticket/2120

Index: buildbot/status/web/logs.py
===================================================================
--- buildbot/status/web/logs.py	(revision 103214)
+++ buildbot/status/web/logs.py	(working copy)
@@ -65,7 +65,7 @@
         if path == "text":
             self.asText = True
             return self
-        return HtmlResource.getChild(self, path, req)
+        return Resource.getChild(self, path, req)
 
     def content(self, entries):
         html_entries = []



**** Added by cmp on 10/4/2011
Fix updateSourceStamp=False to work as expected.

Index: buildbot/steps/trigger.py
===================================================================
--- buildbot/steps/trigger.py
+++ buildbot/steps/trigger.py
@@ -77,15 +77,18 @@ class Trigger(LoggingBuildStep):

         """
         assert schedulerNames, "You must specify a scheduler to trigger"
-        if sourceStamp and updateSourceStamp:
+        if sourceStamp and (updateSourceStamp is not None):
             raise ValueError("You can't specify both sourceStamp and updateSourceStamp")
         if sourceStamp and alwaysUseLatest:
             raise ValueError("You can't specify both sourceStamp and alwaysUseLatest")
-        if alwaysUseLatest and updateSourceStamp:
+        if alwaysUseLatest and (updateSourceStamp is not None):
             raise ValueError("You can't specify both alwaysUseLatest and updateSourceStamp")
         self.schedulerNames = schedulerNames
         self.sourceStamp = sourceStamp
-        self.updateSourceStamp = updateSourceStamp or not (alwaysUseLatest or sourceStamp)
+        if updateSourceStamp is not None:
+            self.updateSourceStamp = updateSourceStamp
+        else:
+            self.updateSourceStamp = not (alwaysUseLatest or sourceStamp)
         self.alwaysUseLatest = alwaysUseLatest
         self.waitForFinish = waitForFinish
         self.set_properties = set_properties


Merge from HEAD to pick up a bug fix.

index 1c7b4ab..7474c0d 100644
--- a/master/buildbot/util/lru.py
+++ b/master/buildbot/util/lru.py
@@ -47,6 +47,7 @@ class AsyncLRUCache(object):
     @ivar hits: cache hits so far
     @ivar refhits: cache misses found in the weak ref dictionary, so far
     @ivar misses: cache misses leading to re-fetches, so far
+    @ivar max_size: maximum allowed size of the cache
     """
 
     __slots__ = ('max_size max_queue miss_fn '
@@ -72,7 +73,7 @@ class AsyncLRUCache(object):
         self.weakrefs = WeakValueDictionary()
         self.concurrent = {}
         self.hits = self.misses = self.refhits = 0
-        self.refcount = defaultdict(default_factory = lambda : 0)
+        self.refcount = defaultdict(lambda : 0)
 
     def get(self, key, **miss_fn_kwargs):
         """
@@ -99,7 +100,7 @@ class AsyncLRUCache(object):
         # utility function to record recent use of this key
         def ref_key():
             queue.append(key)
-            refcount[key] = refcount.get(key, 0) + 1
+            refcount[key] = refcount[key] + 1
 
             # periodically compact the queue by eliminating duplicate keys
             # while preserving order of most recent access.  Note that this
@@ -151,11 +152,12 @@ class AsyncLRUCache(object):
                 cache[key] = result
                 weakrefs[key] = result
 
-            self._purge()
+                # reference the key once, possibly standing in for multiple
+                # concurrent accesses
+                ref_key()
 
-            # reference the key once, possibly standing in for multiple
-            # concurrent accesses
-            ref_key()
+            self.inv()
+            self._purge()
 
             # and fire all of the waiting Deferreds
             dlist = concurrent.pop(key)
@@ -182,8 +184,8 @@ class AsyncLRUCache(object):
         queue = self.queue
         max_size = self.max_size
 
-        # purge least recently used entries, using refcount
-        # to count repeatedly-used entries
+        # purge least recently used entries, using refcount to count entries
+        # that appear multiple times in the queue
         while len(cache) > max_size:
             refc = 1
             while refc:
@@ -216,3 +218,31 @@ class AsyncLRUCache(object):
         self.max_size = max_size
         self.max_queue = max_size * self.QUEUE_SIZE_FACTOR
         self._purge()
+
+    def inv(self):
+        """Check invariants and log if they are not met; used for debugging"""
+        global inv_failed
+
+        # the keys of the queue and cache should be identical
+        cache_keys = set(self.cache.keys())
+        queue_keys = set(self.queue)
+        if queue_keys - cache_keys:
+            log.msg("INV: uncached keys in queue:", queue_keys - cache_keys)
+            inv_failed = True
+        if cache_keys - queue_keys:
+            log.msg("INV: unqueued keys in cache:", cache_keys - queue_keys)
+            inv_failed = True
+
+        # refcount should always represent the number of times each key appears
+        # in the queue
+        exp_refcount = dict()
+        for k in self.queue:
+            exp_refcount[k] = exp_refcount.get(k, 0) + 1
+        if exp_refcount != self.refcount:
+            log.msg("INV: refcounts differ:")
+            log.msg(" expected:", sorted(exp_refcount.items()))
+            log.msg("      got:", sorted(self.refcount.items()))
+            inv_failed = True
+
+# for tests
+inv_failed = False



Truncate comments to maximum length during migration.

Index: db/migrate/versions/001_initial.py
===================================================================
--- db/migrate/versions/001_initial.py	(revision 104114)
+++ db/migrate/versions/001_initial.py	(working copy)
@@ -216,7 +216,7 @@
             values = dict(
                     changeid=c.number,
                     author=c.who,
-                    comments=c.comments,
+                    comments=c.comments[:1024],
                     is_dir=c.isdir,
                     branch=c.branch,
                     revision=c.revision,


Add the 'revlinktmpl' field to GitPoller, used the same way as in
SVNPoller.

Index: buildbot/changes/gitpoller.py
===================================================================
--- buildbot/changes/gitpoller.py	(revision 104853)
+++ buildbot/changes/gitpoller.py	(working copy)
@@ -16,6 +16,7 @@
 import time
 import tempfile
 import os
+import urllib
 from twisted.python import log
 from twisted.internet import defer, utils
 
@@ -36,7 +37,7 @@
                  gitbin='git', usetimestamps=True,
                  category=None, project=None,
                  pollinterval=-2, fetch_refspec=None,
-                 encoding='utf-8'):
+                 encoding='utf-8', revlinktmpl=''):
         # for backward compatibility; the parameter used to be spelled with 'i'
         if pollinterval != -2:
             pollInterval = pollinterval
@@ -57,6 +58,7 @@
         self.changeCount = 0
         self.commitInfo  = {}
         self.initLock = defer.DeferredLock()
+        self.revlinktmpl = revlinktmpl
         
         if self.workdir == None:
             self.workdir = tempfile.gettempdir() + '/gitpoller_work'
@@ -273,6 +275,10 @@
                 # just fail on the first error; they're probably all related!
                 raise failures[0]
 
+            revlink = ''
+            if self.revlinktmpl and rev:
+              revlink = self.revlinktmpl % urllib.quote_plus(rev)
+
             timestamp, name, files, comments = [ r[1] for r in results ]
             d = self.master.addChange(
                    author=name,
@@ -283,7 +289,8 @@
                    branch=self.branch,
                    category=self.category,
                    project=self.project,
-                   repository=self.repourl)
+                   repository=self.repourl,
+                   revlink=revlink)
             wfd = defer.waitForDeferred(d)
             yield wfd
             results = wfd.getResult()

Add limit query argument to /console


--- buildbot/status/web/console.py
+++ buildbot/status/web/console.py
@@ -228,9 +228,9 @@ class ConsoleStatusResource(HtmlResource):
     @defer.deferredGenerator
     def getAllChanges(self, request, status, debugInfo):
         master = request.site.buildbot_service.master
-
+        limit = min(100, max(1, int(request.args.get('limit', [25])[0])))
         wfd = defer.waitForDeferred(
-                master.db.changes.getRecentChanges(25))
+                master.db.changes.getRecentChanges(limit))
         yield wfd
         chdicts = wfd.getResult()
 


Also cache builderName used in console json-like data.

Index: buildbot/status/web/console.py
===================================================================
--- buildbot/status/web/console.py
+++ buildbot/status/web/console.py
@@ -61,12 +61,13 @@ class ANYBRANCH: pass # a flag value, used below

 class CachedStatusBox(object):
     """Basic data class to remember the information for a box on the console."""
-    def __init__(self, color, pageTitle, details, url, tag):
+    def __init__(self, color, pageTitle, details, url, tag, builderName):
         self.color = color
         self.pageTitle = pageTitle
         self.details = details
         self.url = url
         self.tag = tag
+        self.builderName = builderName


 class CacheStatus(object):
@@ -90,7 +91,7 @@ class CacheStatus(object):

     def insert(self, builderName, revision, color, pageTitle, details, url, tag):
         """Insert a new build into the cache."""
-        box = CachedStatusBox(color, pageTitle, details, url, tag)
+        box = CachedStatusBox(color, pageTitle, details, url, tag, builderName)
         if not self.allBoxes.get(builderName):
             self.allBoxes[builderName] = {}

@@ -467,6 +468,7 @@ class ConsoleStatusResource(HtmlResource):
                 s["color"] = "notstarted"
                 s["pageTitle"] = builder
                 s["url"] = "./builders/%s" % urllib.quote(builder)
+                s["builderName"] = builder
                 state, builds = status.getBuilder(builder).getState()
                 # Check if it's offline, if so, the box is purple.
                 if state == "offline":
@@ -521,6 +523,7 @@ class ConsoleStatusResource(HtmlResource):
                     b["pageTitle"] = cached_value.pageTitle
                     b["color"] = cached_value.color
                     b["tag"] = cached_value.tag
+                    b["builderName"] = cached_value.builderName

                     builds[category].append(b)

@@ -577,6 +580,7 @@ class ConsoleStatusResource(HtmlResource):
                 b["pageTitle"] = pageTitle
                 b["color"] = resultsClass
                 b["tag"] = tag
+                b["builderName"] = builder

                 builds[category].append(b)




Re-add support for asHTML to Buildbot (used by ChromiumNotifier).

Index: buildbot/changes/changes.py
===================================================================
--- buildbot/changes/changes.py
+++ buildbot/changes/changes.py
@@ -25,6 +25,25 @@ from buildbot.util import datetime2epoch
 from buildbot import interfaces, util
 from buildbot.process.properties import Properties
 
+html_tmpl = """
+<p>Changed by: <b>%(who)s</b><br />
+Changed at: <b>%(at)s</b><br />
+%(repository)s
+%(branch)s
+%(revision)s
+<br />
+
+Changed files:
+%(files)s
+
+Comments:
+%(comments)s
+
+Properties:
+%(properties)s
+</p>
+"""
+
 class Change:
     """I represent a single change to the source tree. This may involve several
     files, but they are all changed by the same person, and there is a change
@@ -181,6 +200,47 @@ class Change:
         result['project'] = getattr(self, 'project', None)
         return result
 
+    def asHTML(self):
+        info = self.asDict()
+        links = []
+        for file in info['files']:
+            if file['url'] is not None:
+                # could get confused
+                links.append('<a href="%s"><b>%s</b></a>' % (file['url'], file['name']))
+            else:
+                links.append('<b>%s</b>' % file['name'])
+        if info['revision']:
+            if getattr(self, 'revlink', ""):
+                revision = 'Revision: <a href="%s"><b>%s</b></a>\n' % (
+                        info['revlink'], info['revision'])
+            else:
+                revision = "Revision: <b>%s</b><br />\n" % info['revision']
+        else:
+            revision = ''
+
+        if self.repository:
+          repository = "Repository: <b>%s</b><br />\n" % info['repository']
+        else:
+          repository = ''
+
+        branch = ""
+        if info['branch']:
+            branch = "Branch: <b>%s</b><br />\n" % info['branch']
+
+        properties = []
+        for prop in info['properties']:
+            properties.append("%s: %s<br />" % (prop[0], prop[1]))
+
+        kwargs = { 'who'       : html.escape(info['who']),
+                   'at'        : info['at'],
+                   'files'     : html.UL(links) + '\n',
+                   'repository': repository,
+                   'revision'  : revision,
+                   'branch'    : branch,
+                   'comments'  : html.PRE(info['comments']),
+                   'properties': html.UL(properties) + '\n' }
+        return html_tmpl % kwargs
+
     def getShortAuthor(self):
         return self.who
 



Add running_failure build status.

Index: third_party/buildbot_8_4p1/buildbot/status/web/console.py
===================================================================
--- third_party/buildbot_8_4p1/buildbot/status/web/console.py	(revision 105249)
+++ third_party/buildbot_8_4p1/buildbot/status/web/console.py	(working copy)
@@ -25,11 +25,27 @@
 
 class DoesNotPassFilter(Exception): pass # Used for filtering revs
 
-def getResultsClass(results, prevResults, inProgress):
+def isBuildGoingToFail(build):
+    """Returns True if one of the step in the running build has failed."""
+    for step in build.getSteps():
+        if step.getResults()[0] == builder.FAILURE:
+            return True
+    return False
+
+def getInProgressResults(build):
+    """Returns build status expectation for an incomplete build."""
+    if not build.isFinished() and isBuildGoingToFail(build):
+        return builder.FAILURE
+
+    return build.getResults()
+
+def getResultsClass(results, prevResults, inProgress, inProgressResults=None):
     """Given the current and past results, return the class that will be used
     by the css to display the right color for a box."""
 
     if inProgress:
+        if inProgressResults == builder.FAILURE:
+            return "running_failure"
         return "running"
 
     if results is None:
@@ -139,7 +155,7 @@
 class DevBuild:
     """Helper class that contains all the information we need for a build."""
 
-    def __init__(self, revision, build, details):
+    def __init__(self, revision, build, details, inProgressResults=None):
         self.revision = revision
         self.results =  build.getResults()
         self.number = build.getNumber()
@@ -149,6 +165,7 @@
         self.details = details
         self.when = build.getTimes()[0]
         self.source = build.getSourceStamp()
+        self.inProgressResults = inProgressResults
 
 
 class ConsoleStatusResource(HtmlResource):
@@ -331,7 +348,8 @@
             # user that his change might have broken the source update.
             if got_rev and got_rev != -1:
                 details = self.getBuildDetails(request, builderName, build)
-                devBuild = DevBuild(got_rev, build, details)
+                devBuild = DevBuild(got_rev, build, details,
+                                    getInProgressResults(build))
                 builds.append(devBuild)
 
                 # Now break if we have enough builds.
@@ -543,9 +561,11 @@
                 # Get the results of the first build with the revision, and the
                 # first build that does not include the revision.
                 results = None
+                inProgressResults = None
                 previousResults = None
                 if introducedIn:
                     results = introducedIn.results
+                    inProgressResults = introducedIn.inProgressResults
                 if firstNotIn:
                     previousResults = firstNotIn.results
 
@@ -573,7 +593,8 @@
                 if isRunning:
                     pageTitle += ' ETA: %ds' % (introducedIn.eta or 0)
                     
-                resultsClass = getResultsClass(results, previousResults, isRunning)
+                resultsClass = getResultsClass(results, previousResults, isRunning,
+                                               inProgressResults)
 
                 b = {}                
                 b["url"] = url
@@ -591,7 +612,8 @@
 
                 # Add this box to the cache if it's completed so we don't have
                 # to compute it again.
-                if resultsClass not in ("running", "notstarted"):
+                if resultsClass not in ("running", "running_failure",
+                                        "notstarted"):
                   debugInfo["added_blocks"] += 1
                   self.cache.insert(builder, revision.revision, resultsClass,
                                     pageTitle, current_details, url, tag)
@@ -840,4 +862,3 @@
 
     def getSortingKey(self):
         return operator.attrgetter('revision')
-


Fix chrome-bot mis-syncs.

Index: buildbot/changes/svnpoller.py
===================================================================
--- buildbot/changes/svnpoller.py
+++ buildbot/changes/svnpoller.py
@@ -249,6 +249,18 @@ class SVNPoller(base.PollingChangeSource, util.ComparableMixin):
                     new_logentries.append(el)
                 new_logentries.reverse() # return oldest first

+        # If the newest commit's author is chrome-bot, skip this commit.  This
+        # is a guard to ensure that we don't poll on our mirror while it could
+        # be mid-sync.  In that case, the author data could be wrong and would
+        # look like it was a commit by chrome-bot@google.com.  A downside: the
+        # chrome-bot account may have a legitimate commit.  This should not
+        # happen generally, so we're okay waiting to see it until there's a
+        # later commit with a non-chrome-bot author.
+        if len(new_logentries) > 0:
+          if new_logentries[-1].getAttribute("author") == 'chrome-bot@google.com':
+            new_logentries.pop(-1)
+            new_last_change = int(logentries[1].getAttribute("revision"))
+
         self.last_change = new_last_change
         log.msg('svnPoller: _process_changes %s .. %s' %
                 (old_last_change, new_last_change))



Add diagnostic info for an error seen frequently in the wild.

Index: buildbot/db/buildsets.py
===================================================================
--- buildbot/db/buildsets.py	(revision 106949)
+++ buildbot/db/buildsets.py	(working copy)
@@ -131,7 +131,9 @@
                 complete_at=_reactor.seconds())
 
             if res.rowcount != 1:
-                raise KeyError
+                raise KeyError(('"SELECT * FROM buildsets WHERE id=%d AND '
+                                'complete != 1;" returned %d rows') % (
+                                    bsid, res.rowcount))
         return self.db.pool.do(thd)
 
     def getBuildset(self, bsid):
@@ -291,4 +293,3 @@
                 complete=bool(row.complete),
                 complete_at=mkdt(row.complete_at), results=row.results,
                 bsid=row.id)
-


Workaround incomplete Change object.

--- buildbot/status/web/waterfall.py
+++ buildbot/status/web/waterfall.py
@@ -320,7 +320,7 @@ class ChangeEventSource(object):
                 continue
             if categories and change.category not in categories:
                 continue
-            if committers and change.author not in committers:
+            if committers and getattr(change, 'author', None) not in committers:
                 continue
             if minTime and change.when < minTime:
                 continue


Add back support for patch_subdir.

--- buildbot/sourcestamp.py
+++ buildbot/sourcestamp.py
@@ -100,8 +100,8 @@ class SourceStamp(util.ComparableMixin, styles.Versioned):
 
         sourcestamp.patch = None
         if ssdict['patch_body']:
-            # note that this class does not store the patch_subdir
-            sourcestamp.patch = (ssdict['patch_level'], ssdict['patch_body'])
+            sourcestamp.patch = (ssdict['patch_level'], ssdict['patch_body'],
+                ssdict.get('patch_subdir'))
 
         if ssdict['changeids']:
             # sort the changeids in order, oldest to newest
@@ -129,7 +129,7 @@ class SourceStamp(util.ComparableMixin, styles.Versioned):
             return
 
         if patch is not None:
-            assert len(patch) == 2
+            assert 2 <= len(patch) <= 3
             assert int(patch[0]) != -1
         self.branch = branch
         self.patch = patch
@@ -258,12 +258,16 @@ class SourceStamp(util.ComparableMixin, styles.Versioned):
         patch_body = None
         patch_level = None
         if self.patch:
-            patch_level, patch_body = self.patch
+            patch_level = self.patch[0]
+            patch_body = self.patch[1]
+            patch_subdir = None
+            if len(self.patch) > 2:
+              patch_subdir = self.patch[2]
         d = master.db.sourcestamps.addSourceStamp(
                 branch=self.branch, revision=self.revision,
                 repository=self.repository, project=self.project,
                 patch_body=patch_body, patch_level=patch_level,
-                patch_subdir=None, changeids=[c.number for c in self.changes])
+                patch_subdir=patch_subdir, changeids=[c.number for c in self.changes])
         def set_ssid(ssid):
             self.ssid = ssid
             return ssid
